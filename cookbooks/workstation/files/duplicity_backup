#!/bin/bash

### files created by this script shouldn't be world-readable
umask 027

### quick and dirty security warning
if [[ $(id -u) -ge 500 ]]; then
  # assume system users (uid < 500) don't have gui access
  echo 'NOTA BENE: Consider running this script as a non-GUI user (uid < 500) to avoid ENV compromise via e.g. web browser vulnerability.'
  exit 2
fi

### dependency check
if [[ ! -x $(which duplicity) ]]; then
  echo 'Please install duplicity.'
  exit 2
fi

### source secrets
source ${HOME}/.bashrc
if [[ -n ${DUPLICITY_SECRETS} ]] && [[ -r ${DUPLICITY_SECRETS} ]]; then
  if [[ -O ${DUPLICITY_SECRETS} ]] && [[ "$(stat --format '%a' ${DUPLICITY_SECRETS} | cut -c2-)" == "00" ]]; then
    source ${DUPLICITY_SECRETS}
  else
    echo "Please restrict permissions on ${DUPLICITY_SECRETS} and consider changing passwords in case the contents of that file have been compromised."
    exit 2
  fi
else
  echo "Please define environment variable DUPLICITY_SECRETS in ${HOME}/.bashrc."
  echo 'e.g: DUPLICITY_SECRETS=/path/to/secrets'
  echo "NOTA BENE: Please ensure /path/to/secrets is owned by $(id -un) and mode 0400 or 0600."
  exit 2
fi

### VARIABLES WHICH ARE NOT IN ENV
DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP="1M"
DUPLICITY_RETAIN_X_FULL_BACKUPS='2'
DUPLICITY_LOG="/var/log/duplicity.log"
DUPLICITY_LOG_LEVEL="NOTICE"
DUPLICITY_VOL_SIZE_IN_MEGABYTES="100"
# some caching dirs
DUPLICITY_ARCHIVE="${HOME}/.cache/duplicity"
mkdir -p "${DUPLICITY_ARCHIVE}"
DUPLICITY_TMP="/var/tmp"

### ensure log file is writable
touch ${DUPLICITY_LOG} >/dev/null 2>&1
if [[ ! -w ${DUPLICITY_LOG} ]]; then
  echo "Please ensure ${DUPLICITY_LOG} exists and is writable by the current user." | tee --append "${HOME}/DUPLICITY_ERROR"
  echo 'stderr redirected to ~/DUPLICITY_ERROR ...' | tee --append "${HOME}/DUPLICITY_ERROR"
  exit 2
fi

### if destination is local, ensure dir exists and is writable
if [[ -n ${DUPLICITY_DEST} ]] && [[ "$(echo "${DUPLICITY_DEST}" | cut -c1-4)" == "file" ]]; then
  if [[ -z "$(rpm -qf $(echo ${DUPLICITY_DEST} 2>&1 | cut -c8-) | grep -v ' is not owned by any package')" ]]; then
    # ^ TODO support non-rpm distributions + macOS
    mkdir -p "$(echo "${DUPLICITY_DEST}" | cut -c8-)"
    if [[ ! -w "$(echo "${DUPLICITY_DEST}" | cut -c8-)" ]]; then
      echo "Unable to write to $(echo "${DUPLICITY_DEST}" | cut -c8-). Aborting." | tee --append "${DUPLICITY_LOG}"
      exit 2
    fi
  else
    echo "Refusing to back up to an rpm-owned directory. Aborting." | tee --append "${DUPLICITY_LOG}"
    exit 2
  fi
fi

### error out if required ENV variables aren't set
if [[ -z ${DUPLICITY_BASE} ]]; then
  # base dir to back up
  echo 'Please set DUPLICITY_BASE environment variable.' | tee --append "${DUPLICITY_LOG}"
  exit 2
elif [[ -z ${DUPLICITY_DEST} ]]; then
  # where to save the encrypted backup to
  echo 'Please set DUPLICITY_DEST environment variable.' | tee --append "${DUPLICITY_LOG}"
  echo 'e.g: DUPLICITY_DEST="file:///usr/local/backups"' | tee --append "${DUPLICITY_LOG}"
  exit 2
elif [[ -z ${DUPLICITY_INCLUDE} ]]; then
  # what to back up - and what to exclude
  echo 'Please set DUPLICITY_INCLUDE environment variable.' | tee --append "${DUPLICITY_LOG}"
  echo 'e.g: DUPLICITY_INCLUDE="--include=/path/to/example --exlude=/path/to/example/not_this"' | tee --append "${DUPLICITY_LOG}"
  exit 2
elif [[ -z ${PASSPHRASE} ]]; then
  # passphrase for gpg encryption
  echo 'Please set PASSPHRASE environment variable.' | tee --append "${DUPLICITY_LOG}"
  echo 'e.g: PASSPHRASE="secret"' | tee --append "${DUPLICITY_LOG}"
  exit 2
elif [[ "$(echo "${PASSPHRASE}" | pwqcheck -1 min=disabled,64,48,32,32 max=1023)" != "OK" ]]; then
  # gpg2 is OK with long passwords, and if we're backing up to the cloud (recommended), our passphrase should be strong
  # TODO: what's gpg2's limit for symmetric encryption passphrases? 1023 seems fine but pwqcheck needs a max value defined and maybe this is too low
  echo 'ERROR: PASSPHRASE does not meet pwqcheck security requirements. Aborting.' | tee --append "${DUPLICITY_LOG}"
  exit 2
fi

echo -e "\n\nStarting backup $(date --iso-8601=seconds)..." | tee --append "${DUPLICITY_LOG}"

DUPLICITY_OPTIONS="--full-if-older-than ${DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP} ${DUPLICITY_BASE} ${DUPLICITY_DEST} ${DUPLICITY_INCLUDE} --volsize=${DUPLICITY_VOL_SIZE_IN_MEGABYTES} --verbosity=${DUPLICITY_LOG_LEVEL} --gpg-options=--no-use-agent --archive-dir=${DUPLICITY_ARCHIVE} --tempdir=${DUPLICITY_TMP} --log-file=${DUPLICITY_LOG}"

### PURGE EXPIRED LOCAL COPIES
if [[ "$(echo ${DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP} | sed 's/[0-9]//')" == "M" ]]; then
  # assume we're doing monthly full backups
  retention_period=$(( $(($(echo ${DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP} | grep --color=none -o '[0-9]*') * ${DUPLICITY_RETAIN_X_FULL_BACKUPS})) * 31 )) 
else
  # else assume X days is OK..?
  retention_period=180
fi
find "$(echo "${DUPLICITY_DEST}" | cut -c8-)" -mtime +${retention_period} -type f -delete

### PERFORM BACKUP
$(which duplicity) ${DUPLICITY_OPTIONS}

### attempt grive remote sync if backup was local
if [[ "$(echo "${DUPLICITY_DEST}" | cut -c1-4)" == "file" ]]; then
  if [[ "$(echo ${DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP} | sed 's/[0-9]//')" == "M" ]]; then
    # assume we're doing monthly full backups
    retention_period=$(( $(($(echo ${DUPLICITY_FULL_BACKUP_IF_OLDER_THAN_ELSE_INCREMENTAL_BACKUP} | grep --color=none -o '[0-9]*') * ${DUPLICITY_RETAIN_X_FULL_BACKUPS})) * 31 )) 
  else
    # else assume X days is OK..?
    retention_period=180
  fi
  # purge expired local copies
  find "$(echo "${DUPLICITY_DEST}" | cut -c8-)" -mtime +${retention_period} -type f -delete
  if [[ -x $(which grive) ]] && [[ -n ${GRIVE_PATH} ]] && [[ -f ${GRIVE_PATH}/.grive ]] && [[ -n $(echo "${DUPLICITY_DEST}" | cut -c8- | grep -E "^${GRIVE_PATH}") ]]; then
    # sync to google drive (if defined) AND if $GRIVE_PATH contains $DUPLICITY_DEST
    cd "${GRIVE_PATH}" || exit
    # back up and log - do NOT log that a file has already been synched (unnecessary log growth)
    $(which grive) -V 2>&1 | grep -v 'already in sync' | tee --append ${DUPLICITY_LOG} >/dev/null
  else
    echo 'WARNING: not backing up off-site - backup is LOCAL.' | tee --append ${DUPLICITY_LOG}
    echo '--> consider an OFF-SITE backup solution such as grive or s3 <--' | tee --append ${DUPLICITY_LOG}
  fi
# else - backup is already off-site
fi
